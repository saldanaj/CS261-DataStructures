{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red0\green0\blue0;\red170\green13\blue145;
\red63\green110\blue116;\red100\green56\blue32;\red28\green0\blue207;\red38\green71\blue75;}
{\*\expandedcolortbl;\csgray\c100000;\csgenericrgb\c0\c45600\c0;\csgenericrgb\c0\c0\c0;\csgenericrgb\c66500\c5200\c56900;
\csgenericrgb\c24700\c43100\c45600;\csgenericrgb\c39100\c22000\c12500;\csgenericrgb\c11000\c0\c81000;\csgenericrgb\c14900\c27800\c29400;}
\margl1440\margr1440\vieww19300\viewh11920\viewkind0
\deftab543
\pard\tx543\pardeftab543\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \CocoaLigature0 /**\
 * Determines if there is a path from the source to the destination using an\
 * iterative depth-first search starting at the source.\
 * \
 * Remember to call clearVisited() before starting the search.\
 * \
 * @param graph\
 * @param source\
 * @param destination\
 * @return 1 if there is a path, 0 otherwise.\
 */\cf3 \
\cf4 int\cf3  dfsIterative(\cf5 Graph\cf3 * graph, \cf5 Vertex\cf3 * source, \cf5 Vertex\cf3 * destination)\
\{\
    \cf2 // FIXME: Implement\cf3 \
    \cf6 assert\cf3 (graph != \cf7 0\cf3 );\
    \cf6 assert\cf3 (source != \cf7 0\cf3 );\
    \cf6 assert\cf3 (destination != \cf7 0\cf3 );\
    \
    \cf2 // ensure the variable isVisited for each of the\cf3 \
    \cf2 // nodes/vertices in the graph is cleared (set to 0)\cf3 \
    \cf8 clearVisited\cf3 (graph);\
    \
    \cf4 if\cf3 (source == destination)\
    \{\
        \cf4 return\cf3  \cf7 1\cf3 ;\
    \}\
    \
    \cf2 // create the reachable stack and push onto the stack\cf3 \
    \cf2 // the vertices we reached throughout the DFS algorithm\cf3 \
    \cf5 Deque\cf3  *reachableStack  = \cf8 dequeNew\cf3 ();\
    \cf6 assert\cf3 (reachableStack != \cf7 0\cf3 );\
    \
    \cf2 // add the source vertex to the reachable stack\cf3 \
    \cf2 // and we'll pop it after to see what we can reach from there\cf3 \
    \cf8 dequePushBack\cf3 (reachableStack, source);\
    \
    \cf4 while\cf3 (!\cf8 dequeIsEmpty\cf3 (reachableStack));\
    \{\
        \cf2 // assign current the vertex at the "top" of the\cf3 \
        \cf2 // stack and then remove it from the stack\cf3 \
        \cf5 Vertex\cf3  * current = \cf8 dequeBack\cf3 (reachableStack);\
        \
        \cf8 dequePopBack\cf3 (reachableStack);\
        \
        \cf2 // assign the value of 1 to the vertex to it's\cf3 \
        \cf2 // "isVisited" variable to reflect the node/vertex is\cf3 \
        \cf2 // already been visited\cf3 \
        current->\cf5 isVisited\cf3  = \cf7 1\cf3 ;\
        \
        \cf4 if\cf3 (current == destination)\
        \{\
            \cf4 return\cf3  \cf7 1\cf3 ;\
        \}\
        \
        \cf2 // loop through the vertex neighbors\cf3 \
        \cf4 for\cf3 (\cf4 int\cf3  a = \cf7 0\cf3 ; a < current->\cf5 numNeighbors\cf3 ; a++)\
        \{\
            \cf4 if\cf3 (!(current->\cf5 neighbors\cf3 [a]->\cf5 isVisited\cf3 ))\
            \{\
                \cf8 dequePushBack\cf3 (reachableStack, current->\cf5 neighbors\cf3 [a]);\
            \}\
            \
        \}\
    \}\
    \
    \cf2 // delete the reachable stack\cf3 \
    \
    \cf8 dequeDelete\cf3 (reachableStack);\
    \
    \cf2 // return 0 because we were unable to reach the destination\cf3 \
    \cf4 return\cf3  \cf7 0\cf3 ;\
\}\
\
\cf2 /**\
 * Determines if there is a path from the source to the destination using an\
 * iterative breadth-first search starting at the source.\
 * \
 * Remember to call clearVisited() before starting the search.\
 * \
 * @param graph\
 * @param source\
 * @param destination\
 * @return 1 if there is a path, 0 otherwise.\
 */\cf3 \
\cf4 int\cf3  bfsIterative(\cf5 Graph\cf3 * graph, \cf5 Vertex\cf3 * source, \cf5 Vertex\cf3 * destination)\
\{\
    \cf2 // FIXME: Implement\cf3 \
    \
    \cf6 assert\cf3 (graph != \cf7 0\cf3 );\
    \cf6 assert\cf3 (source != \cf7 0\cf3 );\
    \cf6 assert\cf3 (destination != \cf7 0\cf3 );\
    \
    \cf2 // ensure the variable isVisited for each of the\cf3 \
    \cf2 // nodes/vertices in the graph is cleared (set to 0)\cf3 \
    \cf8 clearVisited\cf3 (graph);\
    \
    \cf4 if\cf3 (source == destination)\
    \{\
        \cf4 return\cf3  \cf7 1\cf3 ;\
    \}\
    \
    \cf2 // create the reachable stack and push onto the stack\cf3 \
    \cf2 // the vertices we reached throughout the DFS algorithm\cf3 \
    \cf5 Deque\cf3  *reachableQueue  = \cf8 dequeNew\cf3 ();\
    \cf6 assert\cf3 (reachableQueue != \cf7 0\cf3 );\
    \
    \cf2 // add the source vertex to the reachable stack\cf3 \
    \cf2 // and we'll pop it after to see what we can reach from there\cf3 \
    \cf8 dequePushBack\cf3 (reachableQueue, source);\
    \
    \
    \
    \cf4 while\cf3  (!\cf8 dequeIsEmpty\cf3 (reachableQueue))\
    \{\
        \cf5 Vertex\cf3  *current = \cf8 dequeFront\cf3 (reachableQueue);\
        \
        \cf8 dequePopFront\cf3 (reachableQueue);\
        \
        current->\cf5 isVisited\cf3  = \cf7 1\cf3 ;\
        \
        \cf4 if\cf3  (current == destination)\
        \{\
            \cf4 return\cf3  \cf7 1\cf3 ;\
        \}\
        \
        \cf4 for\cf3  (\cf4 int\cf3  a = \cf7 0\cf3 ; a < current->\cf5 numNeighbors\cf3 ; a++)\
        \{\
            \cf4 if\cf3  (!(current->\cf5 neighbors\cf3 [a]->\cf5 isVisited\cf3 ))\
            \{\
                \cf8 dequePushBack\cf3 (reachableQueue, current->\cf5 neighbors\cf3 [a]);\
            \}\
        \}\
    \}\
    \
    \cf2 // delete the reachable queue\cf3 \
    \cf8 dequeDelete\cf3 (reachableQueue);\
    \
    \cf2 // return 0 because we were unable to reach the destination\cf3 \
    \cf4 return\cf3  \cf7 0\cf3 ;\
\}}